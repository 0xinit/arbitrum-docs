#!/usr/bin/env node

/**
 * Simple script to sync content from stylus-by-example submodule to docs directory
 * Replaces the complex 897-line stylusByExampleDocsHandler.ts
 */

const fs = require('fs-extra');
const path = require('path');
const glob = require('glob');

// Configuration
const SOURCE_DIR = path.join(__dirname, '../submodules/stylus-by-example/src/app');
const TARGET_DIR = path.join(__dirname, '../docs/stylus-by-example');
const DONT_EDIT_MARKER = 'DONT-EDIT-THIS-FOLDER';

/**
 * Convert Next.js style metadata export to Docusaurus frontmatter
 */
function convertMetadataToFrontmatter(content) {
  // Pattern to match: export const metadata = { ... }
  const metadataPattern = /export\s+const\s+metadata\s*=\s*({[\s\S]*?});/;
  const match = content.match(metadataPattern);
  
  if (!match) {
    return content;
  }
  
  try {
    // Extract and parse the metadata object
    const metadataStr = match[1];
    // Use Function constructor to safely evaluate the object literal
    const metadata = new Function(`return ${metadataStr}`)();
    
    // Convert to YAML frontmatter
    const frontmatter = Object.entries(metadata)
      .map(([key, value]) => {
        // Handle different value types
        if (typeof value === 'string') {
          // Escape single quotes in strings
          return `${key}: '${value.replace(/'/g, "''")}'`;
        }
        return `${key}: ${value}`;
      })
      .join('\n');
    
    // Replace the export with frontmatter
    return content.replace(metadataPattern, `---\n${frontmatter}\n---`);
  } catch (error) {
    console.warn(`Warning: Could not convert metadata: ${error.message}`);
    return content;
  }
}

/**
 * Transform relative links to work with Docusaurus structure
 */
function fixRelativeLinks(content) {
  // Fix relative links that point to sibling directories
  // When file name matches directory name, Docusaurus simplifies the URL
  // Pattern: [text](./directory_name) should become [text](/stylus-by-example/basic_examples/directory_name)
  content = content.replace(
    /\[([^\]]+)\]\(\.\/([\w_]+)\)/g,
    (match, linkText, dirName) => {
      // Convert to absolute Docusaurus path (simplified URL when filename matches directory)
      return `[${linkText}](/stylus-by-example/basic_examples/${dirName})`;
    }
  );
  
  return content;
}

/**
 * Process and copy a single MDX file
 */
async function processFile(sourcePath, targetPath) {
  try {
    // Read source file
    let content = await fs.readFile(sourcePath, 'utf8');
    
    // Transform metadata to frontmatter
    content = convertMetadataToFrontmatter(content);
    
    // Fix relative links
    content = fixRelativeLinks(content);
    
    // Add content begin marker if not present
    if (!content.includes('{/* Begin Content */}')) {
      // Find the position after frontmatter
      const frontmatterEnd = content.indexOf('---', 3);
      if (frontmatterEnd !== -1) {
        const insertPos = content.indexOf('\n', frontmatterEnd + 3) + 1;
        content = content.slice(0, insertPos) + '\n{/* Begin Content */}\n' + content.slice(insertPos);
      }
    }
    
    // Ensure target directory exists
    await fs.ensureDir(path.dirname(targetPath));
    
    // Write transformed content
    await fs.writeFile(targetPath, content);
    
    return true;
  } catch (error) {
    console.error(`Error processing ${sourcePath}: ${error.message}`);
    return false;
  }
}

/**
 * Generate sidebar configuration for a directory
 */
function generateSidebar(sectionName, files) {
  const items = files
    .map(file => {
      // Get the relative path from the section directory
      const relativePath = path.relative(path.join(TARGET_DIR, sectionName), file);
      const fileName = path.basename(file, '.mdx');
      const dirName = path.dirname(relativePath);
      
      // Skip if filename is same as directory (already processed)
      if (fileName === sectionName) {
        return null;
      }
      
      // Convert filename to label (snake_case to Title Case)
      const label = fileName
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
      
      // Generate doc ID based on actual file structure
      // For files in subdirectories: stylus-by-example/applications/erc20/erc20
      const docId = dirName === '.' 
        ? `stylus-by-example/${sectionName}/${fileName}`
        : `stylus-by-example/${sectionName}/${dirName}/${fileName}`;
      
      return {
        type: 'doc',
        label: label,
        id: docId
      };
    })
    .filter(Boolean);
  
  return `// @ts-check
/**
 * @fileoverview Autogenerated sidebar configuration for Stylus by Example
 * @description This file is automatically generated by sync-stylus-content.js
 * @generated ${new Date().toISOString()}
 * @see https://docusaurus.io/docs/sidebar
 * @see https://docusaurus.io/docs/sidebar/items
 */

/** @type {import('@docusaurus/plugin-content-docs').SidebarItem[]} */
module.exports = ${JSON.stringify(items, null, 2)};
`;
}

/**
 * Main sync function
 */
async function syncContent() {
  console.log('üîÑ Syncing Stylus by Example content...');
  
  try {
    // Check if source exists
    if (!await fs.pathExists(SOURCE_DIR)) {
      console.warn(`‚ö†Ô∏è  Source directory not found: ${SOURCE_DIR}`);
      console.log('Skipping Stylus by Example content sync.');
      console.log('To include this content, initialize the submodule:');
      console.log('  git submodule update --init --recursive');
      
      // Create empty target directory with marker
      await fs.ensureDir(TARGET_DIR);
      await fs.writeFile(
        path.join(TARGET_DIR, DONT_EDIT_MARKER),
        `This folder would contain auto-generated content from submodules/stylus-by-example
The submodule was not available during build.
Generated: ${new Date().toISOString()}
`
      );
      
      // Create empty sidebar files for the expected directories
      const expectedDirs = ['basic_examples', 'applications'];
      for (const dir of expectedDirs) {
        await fs.ensureDir(path.join(TARGET_DIR, dir));
        const emptySidebar = `// @ts-check
/**
 * @fileoverview Empty sidebar configuration (submodule not available)
 * @generated ${new Date().toISOString()}
 */

/** @type {import('@docusaurus/plugin-content-docs').SidebarItem[]} */
module.exports = [];
`;
        await fs.writeFile(path.join(TARGET_DIR, dir, 'sidebar.js'), emptySidebar);
      }
      
      console.log('‚úÖ Created empty Stylus by Example structure');
      return;
    }
    
    // Clean target directory
    if (await fs.pathExists(TARGET_DIR)) {
      console.log('üßπ Cleaning target directory...');
      await fs.remove(TARGET_DIR);
    }
    
    // Create target directory
    await fs.ensureDir(TARGET_DIR);
    
    // Add marker file
    await fs.writeFile(
      path.join(TARGET_DIR, DONT_EDIT_MARKER),
      `This folder is auto-generated from submodules/stylus-by-example
Do not edit files directly here. Edit them in the submodule instead.
Generated: ${new Date().toISOString()}
`
    );
    
    // Find all page.mdx files
    const pattern = path.join(SOURCE_DIR, '**/page.mdx');
    const files = glob.sync(pattern);
    
    console.log(`üìÅ Found ${files.length} files to process`);
    
    // Process each file
    let successCount = 0;
    for (const sourceFile of files) {
      // Calculate target path
      const relativePath = path.relative(SOURCE_DIR, sourceFile);
      const targetDir = path.dirname(relativePath);
      
      // Rename page.mdx to directory name or keep as index
      let targetFileName;
      if (targetDir === '.') {
        targetFileName = 'index.mdx';
      } else {
        // Use the parent directory name as the filename
        const parentDir = path.basename(targetDir);
        targetFileName = `${parentDir}.mdx`;
      }
      
      const targetFile = path.join(TARGET_DIR, targetDir, targetFileName);
      
      // Process and copy file
      if (await processFile(sourceFile, targetFile)) {
        successCount++;
      }
    }
    
    // Generate sidebars for each directory
    const directories = ['basic_examples', 'applications'];
    for (const dir of directories) {
      const dirPath = path.join(TARGET_DIR, dir);
      if (await fs.pathExists(dirPath)) {
        const dirFiles = glob.sync(path.join(dirPath, '**/*.mdx'));
        const sidebarContent = generateSidebar(dir, dirFiles);
        await fs.writeFile(path.join(dirPath, 'sidebar.js'), sidebarContent);
        console.log(`üìù Generated sidebar for ${dir} (${dirFiles.length} items)`);
      }
    }
    
    console.log(`‚úÖ Successfully synced ${successCount}/${files.length} files`);
    
  } catch (error) {
    console.error(`‚ùå Sync failed: ${error.message}`);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  syncContent();
}

module.exports = { syncContent };
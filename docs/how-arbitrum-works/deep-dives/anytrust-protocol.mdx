---
title: AnyTrust Protocol
description: 'Learn the fundamentals of the Arbitrum AnyTrust protocol.'
author: pete-vielhaber
sme: TucksonDev
user_story: As a current or prospective Arbitrum user, I need to learn more about AnyTrust.
content_type: concept
---

AnyTrust is a variant of the <a data-quicklook-from="arbitrum">Arbitrum</a> Nitro technology that lowers costs by accepting a mild trust assumption.

The Arbitrum protocol requires that all Arbitrum nodes, including validators (nodes that verify the correctness of the chain and place bonds on correct results), have access to the data of every child chain <a data-quicklook-from="transaction">transaction</a> in the <a data-quicklook-from="arbitrum-chain">Arbitrum chain</a>’s inbox. An Arbitrum Rollup provides data access by posting the data (in batched, compressed form) on the parent chain, Ethereum, as blobs or calldata. The Ethereum gas used to pay for this is the largest component of the cost of using Arbitrum.

AnyTrust relies instead on an external Data Availability Committee (DAC) to store data and provide it on demand. The DAC has N members, of which AnyTrust assumes at least two are honest. This means that if `N - 1` DAC members promise to provide access to some data, at least one of them must be honest. Since there are two honest members and only one failed to keep the promise, it follows that at least one of the promisers must be honest, and that honest member will provide data when needed to ensure the chain can properly function.

## Keysets

A Keyset specifies the [Boneh–Lynn–Shacham (BLS)](https://en.wikipedia.org/wiki/BLS_digital_signature) public keys of DAC members and the number of signatures required for a <a data-quicklook-from="data-availability-certificate">Data Availability Certificate</a> (DACert) to be valid. Keysets enable DAC membership changes and allow DAC members to change their keys.

A Keyset contains:

- The number of DAC members, and
- For each DAC member, a BLS public key, and
- The number of DAC signatures required.

Keysets are identified by their hashes. A parent chain `KeysetManager` contract maintains a list of currently valid Keysets. The child chain’s `Owner` can add or remove Keysets from this list. When a Keyset becomes valid, the `KeysetManager` contract emits a parent-chain Ethereum event that includes the Keyset’s hash and full contents. This allows the contents to be recovered later by anyone, given only the Keyset hash.

Although the API does not limit the number of Keysets that can be valid simultaneously, only one Keyset is normally valid.

## Data Availability Certificates

A central concept in AnyTrust is the Data Availability Certificate (hereafter, a “DACert”). A DACert will contain:

- The hash of a data block
- An expiration time
- Proof that the N -1 DAC members have signed the pair (hash, expiration time), consisting of:
  - The hash of the Keyset used in signing
  - A bitmap showing which DAC members signed
  - A BLS aggregated signature (over the BLS12-381 curve) proving that those parties signed.

Because of the `2-of-N` trust assumption, a DACert constitutes proof that the block’s data (i.e., the preimage of the hash in the DACert) will be available from at least one honest DAC member, at least until the expiration time expires.

In regular Arbitrum Nitro, the Arbitrum <a data-quicklook-from="sequencer">Sequencer</a> posts data blocks on the parent chain as blobs or calldata. The hashes of the data blocks are committed to the parent chain Inbox contract, allowing the data to be reliably read by the child chain code.

AnyTrust gives the sequencer two ways to post a data block on parent chain: it can post the full data as above, or it can post a DACert proving availability of the data. The parent chain inbox contract will reject any DACert that uses an invalid Keyset; the other aspects of DACert validity are checked by the child chain code.

The child chain code that reads data from the inbox reads a full-data block as in ordinary Arbitrum Nitro. If it sees a DACert instead, it checks the DACert's validity, using the Keyset specified by the DACert (which is known to be valid because the parent chain inbox verified it). The child chain code verifies that:

- The number of signers is equal to or greater than the number required by the Keyset
- The aggregated signature is valid for the claimed signers
- The expiration time is at least two weeks after the current child chain timestamp

If the DACert is invalid, the child chain code discards it and proceeds to the next data block. If the DACert is valid, the child chain code reads the data block, which is guaranteed to be available because the DACert is valid.

## Data Availability Servers

DAC members run the Data Availability Server (DAS) software. The DAS exposes two APIs:

- The Sequencer API, intended only for the Arbitrum chain’s Sequencer, is a JSON-RPC interface that enables the Sequencer to submit data blocks to the DAS for storage. Production deployments will typically block access to this API from callers other than the Sequencer.
- The REST API, intended to be available to the world, is a RESTful HTTP(s)-based protocol that allows data blocks to be fetched by hash. This API is fully cacheable, and deployments may use a caching proxy or CDN to increase scale and protect against DoS attacks.

Only DAC members have a reason to support the Sequencer API. We expect others to run the REST API, which is helpful (discussed below).

The DAS software, based on configuration options, can store its data in local files, in a BadgerDB database, on Amazon S3, or redundantly across multiple backing data stores. The software also supports optional caching in memory (using Bigcache) or in a Redis instance.

## Sequencer-DAC interaction

When the Arbitrum Sequencer produces a data <a data-quicklook-from="batch">batch</a> that it wants to post using the DAC, it sends the batch’s data, along with the expiration time (normally, three weeks in the future) via RPC to all DAC members in parallel. Each DAC member stores the data in its backing store, indexed by the data’s hash. Then the member signs the pair (hash, expiration time) using its BLS key, and returns the signature with a success indicator to the sequencer.

Once the sequencer has collected enough signatures, it can aggregate the signatures and create a valid DACert for the pair (hash, expiration time). The sequencer then posts that DACert to the parent chain Inbox contract, making it available to the AnyTrust chain software on the child chain.

If the sequencer fails to collect enough signatures within a few minutes, it will abandon the attempt to use the DAC and will “fall back to Rollup mode” by posting the full data directly to the parent chain, as it would do in a non-AnyTrust chain. The child chain software can understand both data posting formats (via DACert or full data) and will handle each one correctly.

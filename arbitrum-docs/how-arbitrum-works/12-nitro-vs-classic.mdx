---
title: Nitro vs. Classic
author: dzgoldman
---

## Why Nitro?
Nitro marks a significant leap forward in Arbitrum technology. This upgrade surpasses the tech stack initially launched on the Arbitrum One mainnet, now known as "Arbitrum Classic." It has evolved far beyond the original [Arbitrum whitepaper from 2018](https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-kalodner.pdf). This overview will assertively detail the rationale behind the Nitro upgrade and clearly outline its key advantages over the classic system. 

The Classic and Nitro systems designs are similar: to establish an execution environment that closely mirrors the Ethereum Virtual Machine (EVM), operating as a robust second layer to Ethereum. This architecture guarantees the safety of Layer 2 (L2) virtual machine state updates, enforced through succinct fraud proofs on Ethereum itself. 

In Arbitrum Classic, we achieved this goal using a custom-built virtual machine known as the Arbitrum Virtual Machine (AVM). The L2 state machine implementation, called "[ArbOS](/how-arbitrum-works/arbos/introduction.mdx)," is a program compiled and uploaded to the AVM, allowing it to emulate EVM execution and various other functionalities. 

With Nitro, we shift from relying on the AVM for low-level instructions to employing WebAssembly (Wasm). This shift allows us to compile Go code into Wasm, enabling the ArbOS program to be implemented in Go while incorporating [Geth](/how-arbitrum-works/arbos/geth.mdx) itself (as a sub-module). Geth is Ethereum's most widely employed implementation, underscoring our commitment to compatibility and efficiency. 

Nitro's core strength lies in its innovative architecture, seamlessly integrating Geth's EVM implementation. Most of Nitro's benefits arise directly or indirectly from this design choice, offering lower fees, enhanced compatibility with Ethereum, and simplicity.

## Lower Fees

### (Optimistic)^2 Execution
In Classic, high-level code—such as Solidity and Vyper—is compiled into EVM bytecode as if it were deployable on Ethereum. This bytecode is then transpiled by ArbOS into its corresponding AVM instructions. The resulting AVM bytecode serves as the instructions for operating the Layer 2 (L2) virtual machine and provides the necessary inputs for proving fraud. In the event of an interactive fraud proof, two validators dive deep into a segment of AVM bytecode until they establish a "one-step proof"—a state transition that showcases a single AVM opcode executed within the EVM of Layer 1 (L1).

Nitro adopts a similar bytecode "sandwich" structure. To tackle [fraud proofing in Nitro](how-arbitrum-works/fraud-proofs/challenge-manager.mdx), the node's Go code is compiled into WebAssembly (Wasm), with individual instructions meticulously analyzed to flush out any invalid state updates. However, a crucial advantage of Nitro is its ability to periodically produce blocks akin to those in Ethereum, acting as natural state checkpoints within the broader context of an L2 state update. Nitro harnesses this strength by decisively splitting the interactive fraud proof process into two phases:

- Phase 1: The disputing parties sharpen their focus to resolve their disagreement to a single block.  
- Phase 2: They compile that block into Wasm, further drilling down to Wasm instructions.

Notably, the Wasm compilation occurs only when disputes arise, maintaining efficiency.

It's worth emphasizing this distinction: in Classic, the code executed in the happy/common case is identical to the code in the fraud proof. In stark contrast, Nitro allows for distinctly different contexts for execution and proving. When a dispute emerges, we compile down to Wasm bytecode; however, during standard operations, the node's Go code runs natively, leveraging whatever execution environment is on the machine. Nitro confidently adopts a more "optimistic" approach to execution, compiling to Wasm only as necessary. This native execution method guarantees superior speed and efficiency, leading to enhanced node performance that translates directly into lower fees for end users.

### Calldata Compression

Most Arbitrum Rollup transactions' fees cover the essential cost of posting data on Ethereum. Any rollup must post sufficient data on Layer 1 (L1) to effectively reconstruct and validate the Layer 2 (L2) state. While L2s can choose their data formats, the high costs associated with posting data to L1 make it critical to implement optimizations. A highly effective strategy is to compress data (losslessly) before posting it on L1, allowing the L2 environment to manage decompression.

The Arbitrum core architecture's flexibility makes decompression possible, even with the Classic Arbitrum Virtual Machine (AVM). However, because the AVM is custom-built for Arbitrum, developing a proprietary implementation of a compression algorithm would have introduced excessive technical risks.

In contrast, the Nitro architecture only requires its Virtual Machine (VM) to compile to WebAssembly (Wasm), meaning Ge th and any Go code are easily incorporated. This innovative approach allows Nitro to leverage widely adopted and tested compression libraries for calldata compression, drastically reducing the costs of posting transaction batches.

Additionally, supporting calldata compression demands a sophisticated mechanism to accurately determine the [price of calldata](/how-arbitrum-works/l1-gas-pricing.mdx) and ensure that batch posters receive appropriate compensation. Nitro effectively addresses these challenges, solidifying its framework for efficient operation.

## Closer EVM Compatibility

The Classic AVM demonstrated impressive EVM compatibility by effectively handling all EVM opcodes. However, its internal behavior diverged significantly from that of the EVM. A key concern for smart contract developers was the introduction of "ArbGas," a denomination whose units do not align with Ethereum L1 gas. For instance, a simple transfer requires 21,000 gas on L1 but a staggering 100,000 ArbGas within the AVM. This discrepancy necessitated modifications to contracts that relied on gas calculation logic designed for L1 before deployment on L2. It also affected client-side tools that operated under similar fixed assumptions about gas on a blockchain. Nitro resolves this issue with [gas](/how-arbitrum-works/gas-fees.mdx) costs on L1 and L2 corresponding directly in a 1:1 ratio.

:::note

Transactions must account for the total expenses of L2 execution and L1 calldata. The values returned by Arbitrum nodes' `eth_estimateGas` RPC, which users see in their wallets, are designed to ensure they effectively cover this entire cost. Refer to the [2-D fees](https://medium.com/offchainlabs/understanding-arbitrum-2-dimensional-fees-fd1d582596c9) for more details.

:::

Furthermore, Nitro enhances node functionality beyond execution, ensuring compatibility with many tools and infrastructure expectations—such as transaction tracing—available out of the box. This feature makes Nitro more compatible with Ethereum at the virtual machine level and how clients interact with the blockchain.

In summary, leveraging Ethereum's software is undeniably the best approach to achieving compatibility with Ethereum.

## Simplicity

Maintaining code that is simple and easy to understand for Layer 2 systems is essential, given their inherent complexity. The classic stack consists of a large, in-house codebase that demands considerable time and effort to analyze effectively. In stark contrast, the Arbitrum Virtual Machine (AVM) and ArbOS combined constitute a robust blockchain protocol built from the ground up. The AVM was custom-built and lacked high-level languages at that time, forcing the implementation of ArbOS logic using a custom language called "mini," along with a mini-to-AVM compiler. 

Nitro's direct usage of Geth means most of the work of creating an L2 VM is inherited right out of the box. The ArbOS custom logic (which, happily, can now be written in Go instead of mini) is much slimmer than in the classic stack; since the Geth software now handles the work of emulating the EVM, ArbOS needs only to implement the things-specific and necessary for layer 2 (i.e., L1/L2 gas accounting, special message types for cross-chain transactions, etc.) Leaner, simpler code — much of which directly inherits engineering hours put into Ethereum-Geth itself — makes it a system far more accessible for auditors and contributors, giving us strong confidence in its implementation security that will only harden as the ecosystem grows.

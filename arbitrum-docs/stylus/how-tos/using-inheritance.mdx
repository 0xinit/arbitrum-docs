---
title: 'Using Inheritance Patterns in Stylus Contracts'
description: 'Learn how to implement inheritance patterns in your Stylus smart contracts'
author: anegg0
sme: mahsamoosavi
content_type: how-to
sidebar_position: 1
---

import CustomDetails from '@site/src/components/CustomDetails';
import VanillaAdmonition from '@site/src/components/VanillaAdmonition';

# How To Implement Inheritance Patterns in Stylus

Inheritance is a powerful design pattern that allows you to build upon existing smart contract functionality without duplicating code. In Stylus, the Rust SDK provides tools to implement inheritance patterns similar to Solidity, but with some important differences. This guide walks you through implementing inheritance in your Stylus smart contracts.

## Overview

Stylus allows you to write smart contracts in Rust that are fully interoperable with EVM contracts. The inheritance model in Stylus aims to replicate the composition pattern found in Solidity, where types that implement the Router trait (provided by the `#[public]` macro) can be connected via inheritance.

<VanillaAdmonition type="warning" title="Inheritance Limitation">
  Stylus doesn't currently support contract multi-inheritance, so you should design your contracts accordingly.
</VanillaAdmonition>

## Getting Started

Before implementing inheritance, ensure you have:

1. Installed the Rust toolchain
2. Installed `cargo-stylus` CLI tool: `cargo install --force cargo-stylus`
3. Set up a Stylus project: `cargo stylus new your_project_name`

## Basic Inheritance Pattern

The inheritance pattern in Stylus requires two main components:

1. A storage structure using the `#[borrow]` annotation
2. An implementation block using the `#[inherit]` annotation

Let's walk through a practical example.

### Step 1: Define the Base Contract

First, define your base contract that will be inherited:

<CustomDetails summary="Base Contract Example">

```rust
use stylus_sdk::{alloy_primitives::U256, prelude::*};

sol_storage! {
    pub struct BaseContract {
        uint256 value;
    }
}

#[public]
impl BaseContract {
    pub fn get_value(&self) -> Result<U256, Vec<u8>> {
        Ok(self.value.get())
    }
    
    pub fn set_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        self.value.set(new_value);
        Ok(())
    }
}
```

</CustomDetails>

### Step 2: Define the Child Contract with Inheritance

Next, create your child contract that inherits from the base contract:

<CustomDetails summary="Child Contract Example">

```rust
sol_storage! {
    #[entrypoint]
    pub struct ChildContract {
        #[borrow]
        BaseContract base_contract;
        uint256 additional_value;
    }
}

#[public]
#[inherit(BaseContract)]
impl ChildContract {
    pub fn get_additional_value(&self) -> Result<U256, Vec<u8>> {
        Ok(self.additional_value.get())
    }
    
    pub fn set_additional_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        self.additional_value.set(new_value);
        Ok(())
    }
}
```

</CustomDetails>

### How It Works

When you add the `#[entrypoint]` macro to your `ChildContract` struct, calls to the contract will first check if the requested method exists within `ChildContract`. If a matching function is not found, it will then try the `BaseContract`. Only after trying everything `ChildContract` inherits will the call revert.

The `#[borrow]` annotation in your storage declaration is crucial for inheritance to work properly, as it allows the child contract to access the base contract's storage.

## Method Overriding

If both parent and child implement the same method, the one in the child will override the one in the parent, which won't be callable. This allows for patterns where you import a crate implementing a standard, like an ERC-20, and then add or override just the methods you want to without modifying the imported type.

For example:

<CustomDetails summary="Method Overriding Example">

```rust
#[public]
#[inherit(BaseContract)]
impl ChildContract {
    // This overrides the base_contract.set_value method
    pub fn set_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        // Custom implementation
        if new_value > U256::from(100) {
            return Err("Value too large".as_bytes().to_vec());
        }
        self.base_contract.set_value(new_value)?;
        Ok(())
    }
}
```

</CustomDetails>

<VanillaAdmonition type="caution" title="No Explicit Override Keywords">
  Stylus does not currently contain explicit `override` or `virtual` keywords for marking override functions. It is important to carefully ensure that contracts are only overriding the functions you intend to override.
</VanillaAdmonition>

## Storage Layout Considerations

<VanillaAdmonition type="info" title="Storage Layout in Inherited Contracts">
  Note that one exception to Stylus's storage layout guarantee is contracts which utilize inheritance. The current solution in Stylus using `#[borrow]` and `#[inherits(...)]` packs nested (inherited) structs into their own slots. This is consistent with regular struct nesting in Solidity, but not with inherited structs.
</VanillaAdmonition>

This has important implications when upgrading from Solidity to Rust, as storage slots may not align the same way.

## Working Example: ERC-20 Token with Inheritance

A practical example of inheritance in Stylus is implementing an ERC-20 token with custom functionality. Here's how it works:

<CustomDetails summary="ERC-20 Implementation with Inheritance">

```rust
// Define the base ERC-20 functionality
struct StylusTokenParams;
impl Erc20Params for StylusTokenParams {
    const NAME: &'static str = "StylusToken";
    const SYMBOL: &'static str = "STK";
    const DECIMALS: u8 = 18;
}

sol_storage! {
    #[entrypoint]
    struct StylusToken {
        #[borrow]
        Erc20<StylusTokenParams> erc20;
    }
}

#[public]
#[inherit(Erc20<StylusTokenParams>)]
impl StylusToken {
    // Add custom functionality
    pub fn mint(&mut self, value: U256) -> Result<(), Erc20Error> {
        self.erc20.mint(msg::sender(), value)?;
        Ok(())
    }
}
```

</CustomDetails>

This example shows how to inherit from a generic ERC-20 implementation and add custom minting functionality.

## Current Limitations

1. Stylus doesn't support contract multi-inheritance yet
2. The storage layout for inherited contracts differs from Solidity's inheritance model
3. There's a risk of undetected selector collisions with functions from inherited contracts

## Best Practices

1. Use `cargo expand` to examine the expanded code and verify inheritance is working as expected
2. Be cautious with method overriding since there are no explicit override keywords
3. Design your contracts with single inheritance in mind
4. Test thoroughly to ensure all inherited methods work correctly
5. Be aware of potential storage layout differences when migrating from Solidity

## Conclusion

Inheritance in Stylus provides a powerful way to compose contracts and reuse code. While it has some limitations compared to Solidity's inheritance model, it offers a familiar pattern for developers coming from Solidity and enables clean extension of existing functionality.

By following the patterns outlined in this guide, you can create modular, extensible smart contracts in Rust that leverage inheritance while maintaining full EVM compatibility.

For more information, refer to the [Stylus SDK documentation](https://docs.arbitrum.io/stylus/reference/rust-sdk-guide).
